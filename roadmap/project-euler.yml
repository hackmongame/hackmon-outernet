name: Project Euler
pos: [0, 0]
levels:
  - title: 'Multiples of 3 and 5'
    code: |
      export function multiplesOf3and5(number) {
        // Your code here
        return true;
      }
    description: |
      If we list all the natural numbers below 10 that are multiples of 3 and 5, we get 3, 5, 6, and 9. The sum of these multiples is 23.

      Find the sum of all the multiples of 3 or 5 below the provided parameter value `number`.
    tests:
      '`multiplesOf3and5(10)` should return a number': |
        describe("multiplesOf3and5(10) should return a number", () => {
            expect(multiplesOf3and5(10)).toEqual(expect.any(Number))
        })
      '`multiplesOf3and5(49)` should return 543': |
        describe("multiplesOf3and5(49) should return 543", () => {
            expect(multiplesOf3and5(49)).toBe(543)
        })
      '`multiplesOf3and5(1000)` should return 233168': |
        describe("multiplesOf3and5(1000) should return 233168", () => {
            expect(multiplesOf3and5(1000)).toBe(233168)
        })
      '`multiplesOf3and5(8456)` should return 16687353': |
        describe("`multiplesOf3and5(8456)` should return 16687353", () => {
          expect(multiplesOf3and5(8456)).toBe(16687353)
        })
      '`multiplesOf3and5(19564)` should return 89301183': |
        describe("multiplesOf3and5(19564) should return 89301183", () => {
            expect(multiplesOf3and5(19564)).toBe(89301183)
        })
  - title: 'Even Fibonacci Numbers'
    code: |
      export function fiboEvenSum(n) {
        // Your code here
        return true;
      }
    description: |
      Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

      ```
      1, 2, 3, 5, 8, 13, 21, 34, 55, 89
      ```

      By considering the terms in the Fibonacci sequence whose values do not exceed `n`, find the sum of the even-valued terms.
    tests:
      '`fiboEvenSum(10)` should return a number': |
        describe("fiboEvenSum(10) should return a number", () => {
            expect(fiboEvenSum(10)).toEqual(expect.any(Number))
        })
      'Your function should sum the even-valued Fibonacci numbers: `fiboEvenSum(8)` should return 10':
        |
        describe("`fiboEvenSum(8)` should return 10", () => {
          expect(fiboEvenSum(8)).toBe(10)
        })
      '`fiboEvenSum(10)` should return 10.': |
        describe("fiboEvenSum(10) should return 10", () => {
          expect(fiboEvenSum(10)).toBe(10)
        })
      '`fiboEvenSum(34)` should return 44': |
        describe("fiboEvenSum(34) should return 44", () => {
          expect(fiboEvenSum(34)).toBe(44)
        })
      '`fiboEvenSum(60)` should return 44': |
        describe("fiboEvenSum(60) should return 44", () => {
          expect(fiboEvenSum(60)).toBe(44)
        })
      '`fiboEvenSum(1000)` should return 798': |
        describe("fiboEvenSum(1000) should return 798", () => {
          expect(fiboEvenSum(1000)).toBe(798)
        })
      '`fiboEvenSum(100000)` should return 60696': |
        describe("fiboEvenSum(100000) should return 60696", () => {
          expect(fiboEvenSum(100000)).toBe(60696)
        })
      '`fiboEvenSum(4000000)` should return 4613732': |
        describe("fiboEvenSum(4000000) should return 4613732", () => {
          expect(fiboEvenSum(4000000)).toBe(4613732)
        })
  - title: 'Largest Prime Factor'
    code: |
      export function largestPrimeFactor(number) {
        // Your code here
        return true;
      }
    description: |
      The prime factors of 13195 are 5, 7, 13, and 29.

      What is the largest prime factor of the given `number`?
    tests:
      '`largestPrimeFactor` should return a number': |
        describe("largestPrimeFactor should return a number", () => {
          expect(largestPrimeFactor(2)).toEqual(expect.any(Number))
        })
      '`largestPrimeFactor(2)` should return 2': |
        describe("largestPrimeFactor(2) should return 2", () => {
          expect(largestPrimeFactor(2)).toBe(2)
        })
      '`largestPrimeFactor(3)` should return 3': |
        describe("largestPrimeFactor(3) should return 3", () => {
          expect(largestPrimeFactor(3)).toBe(3)
        })
      '`largestPrimeFactor(5)` should return 5': |
        describe("largestPrimeFactor(5) should return 5", () => {
          expect(largestPrimeFactor(5)).toBe(5)
        })
      '`largestPrimeFactor(7)` should return 7': |
        describe("largestPrimeFactor(7) should return 7", () => {
          expect(largestPrimeFactor(7)).toBe(7)
        })
      '`largestPrimeFactor(8)` should return 2': |
        describe("largestPrimeFactor(8) should return 2", () => {
          expect(largestPrimeFactor(8)).toBe(2)
        })
      '`largestPrimeFactor(13195)` should return 29': |
        describe("largestPrimeFactor(13195) should return 29", () => {
          expect(largestPrimeFactor(13195)).toBe(29)
        })
      '`largestPrimeFactor(600851475143)` should return 6857': |
        describe("largestPrimeFactor(600851475143) should return 6857", () => {
          expect(largestPrimeFactor(600851475143)).toBe(6857)
        })
  - title: 'Largest Palindrome Product'
    code: |
      export function largestPalindromeProduct(n) {
        // Your code here
        return true;
      }
    description: |
      A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.

      Find the largest palindrome made from the product of two `n`-digit numbers.
    tests:
      '`largestPalindromeProduct(2)` should return a number': |
        describe("largestPalindromeProduct(2) should return a number", () => {
          expect(largestPalindromeProduct(2)).toEqual(expect.any(Number))
        })
      '`largestPalindromeProduct(2)` should return 9009': |
        describe("largestPalindromeProduct(2) should return 9009", () => {
          expect(largestPalindromeProduct(2)).toBe(9009)
        })
      '`largestPalindromeProduct(3)` should return 906609': |
        describe("largestPalindromeProduct(3) should return 906609", () => {
          expect(largestPalindromeProduct(3)).toBe(906609)
        })
  - title: 'Smallest Multiple'
    code: |
      export function smallestMult(n) {
        // Your code here
        return true;
      }
    description: |
      2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

      What is the smallest positive number that is evenly divisible by all the numbers from 1 to `n`?
    tests:
      '`smallestMult(5)` should return a number': |
        describe("smallestMult(5) should return a number", () => {
          expect(smallestMult(5)).toEqual(expect.any(Number))
        })
      '`smallestMult(5)` should return 60': |
        describe("smallestMult(5) should return 60", () => {
          expect(smallestMult(5)).toBe(60)
        })
      '`smallestMult(7)` should return 420': |
        describe("smallestMult(7) should return 420", () => {
          expect(smallestMult(7)).toBe(420)
        })
      '`smallestMult(10)` should return 2520': |
        describe("smallestMult(10) should return 2520", () => {
          expect(smallestMult(10)).toBe(2520)
        })
      '`smallestMult(13)` should return 360360': |
        describe("smallestMult(13) should return 360360", () => {
          expect(smallestMult(13)).toBe(360360)
        })
      '`smallestMult(20)` should return 232792560': |
        describe("smallestMult(20) should return 232792560", () => {
          expect(smallestMult(20)).toBe(232792560)
        })
  - title: '10001st prime'
    code: |
      export function nthPrime(n) {
        // Your code here
        return true;
      }
    description: |
      By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

      What is the `n`th prime number?
    tests:
      '`nthPrime(6)` should return a number': |
        describe("nthPrime(6) should return a number", () => {
          expect(nthPrime(6)).toEqual(expect.any(Number))
        })
      '`nthPrime(6)` should return 13': |
        describe("nthPrime(6) should return 13", () => {
          expect(nthPrime(6)).toBe(13)
        })
      '`nthPrime(10)` should return 29': |
        describe("nthPrime(10) should return 29", () => {
          expect(nthPrime(10)).toBe(29)
        })
      '`nthPrime(100)` should return 541': |
        describe("nthPrime(100) should return 541", () => {
          expect(nthPrime(100)).toBe(541)
        })
      '`nthPrime(1000)` should return 7919': |
        describe("nthPrime(1000) should return 7919", () => {
          expect(nthPrime(1000)).toBe(7919)
        })
      '`nthPrime(10001)` should return 104743': |
        describe("nthPrime(10001) should return 104743", () => {
          expect(nthPrime(10001)).toBe(104743)
        })
  - title: 'Summation of Primes'
    code: |
      export function primeSummation(n) {
        // Your code here
        return true;
      }
    description: |
      The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

      Find the sum of all the primes below `n`.
    tests:
      '`primeSummation(17)` should return a number': |
        describe("primeSummation(17) should return a number", () => {
          expect(primeSummation(17)).toEqual(expect.any(Number))
        })
      '`primeSummation(17)` should return 41': |
        describe("primeSummation(17) should return 41", () => {
          expect(primeSummation(17)).toBe(41)
        })
      '`primeSummation(2001)` should return 277050': |
        describe("primeSummation(2001) should return 277050", () => {
          expect(primeSummation(2001)).toBe(277050)
        })
      '`primeSummation(140759)` should return 873608362': |
        describe("primeSummation(140759) should return 873608362", () => {
          expect(primeSummation(140579)).toBe(873608362)
        })
      '`primeSummation(2000000)` should return 142913828922': |
        describe("primeSummation(2000000) should return 142913828922", () => {
          expect(primeSummation(2000000)).toBe(142913828922)
        })
  - title: 'Highly divisble triangular number'
    code: |
      export function divisibleTriangleNumber(n) {
        // Your code here
        return true;
      }
    description: |
      The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

      Let us list the factors of the first seven triangle numbers:

      1: 1
      3: 1, 3
      6: 1, 2, 3, 6
      10: 1, 2, 5, 10
      15: 1, 3, 5, 15
      21: 1, 3, 7, 21
      28: 1, 2, 4, 7, 14, 28

      We can see that 28 is the first triangle number to have over five divisors.

      What is the value of the first triangle number to have over `n` divisors?
    tests:
      '`divisibleTriangleNumber(5)` should return a number': |
        describe("divisibleTriangleNumber(5) should return a number", () => {
          expect(divisibleTriangleNumber(5)).toEqual(expect.any(Number))
        })
      '`divisibleTriangleNumber(5)` should return 28': |
        describe("divisibleTriangleNumber(5) should return 28", () => {
          expect(divisibleTriangleNumber(5)).toBe(28)
        })
      '`divisibleTriangleNumber(23)` should return 630': |
        describe("divisibleTriangleNumber(23) should return 630", () => {
          expect(divisibleTriangleNumber(23)).toBe(630)
        })
      '`divisibleTriangleNumber(167)` should return 1385280': |
        describe("divisibleTriangleNumber(167) should return 1385280", () => {
          expect(divisibleTriangleNumber(167)).toBe(1385280)
        })
      '`divisibleTriangleNumber(374)` should return 17907120': |
        describe("divisibleTriangleNumber(374) should return 17907120", () => {
          expect(divisibleTriangleNumber(374)).toBe(17907120)
        })
      '`divisibleTriangleNumber(500)` should return 76576500': |
        describe("divisibleTriangleNumber(500) should return 76576500", () => {
          expect(divisibleTriangleNumber(500)).toBe(76576500)
        })
